<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BFD9020 API Tester</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-color: #0f172a;
      color: #e2e8f0;
    }

    body {
      margin: 0;
      padding: 2rem;
      max-width: 960px;
      margin-inline: auto;
      line-height: 1.5;
      background: radial-gradient(circle at top, rgba(59,130,246,0.1), transparent 55%);
    }

    h1 {
      margin-bottom: 0.25rem;
      font-size: 1.8rem;
    }

    p.lede {
      margin-top: 0;
      color: #94a3b8;
    }

    .panel {
      background: rgba(15,23,42,0.85);
      border: 1px solid rgba(148,163,184,0.2);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 10px 30px rgba(15,23,42,0.4);
      margin-bottom: 1.5rem;
    }

    label {
      font-size: 0.9rem;
      color: #cbd5f5;
      display: inline-flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    input[type="text"] {
      padding: 0.65rem 0.85rem;
      background: rgba(15,23,42,0.8);
      border: 1px solid rgba(148,163,184,0.3);
      border-radius: 10px;
      color: inherit;
      width: min(360px, 100%);
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.55rem 1rem;
      background: linear-gradient(120deg, #22d3ee, #3b82f6);
      color: #0f172a;
      font-weight: 600;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(59,130,246,0.35);
    }

    #dropzone {
      border: 2px dashed rgba(148,163,184,0.6);
      border-radius: 16px;
      padding: 2rem;
      text-align: center;
      color: #94a3b8;
      cursor: pointer;
      transition: border-color 150ms ease, background 150ms ease;
    }

    #dropzone.dragover {
      border-color: #38bdf8;
      background: rgba(56,189,248,0.05);
      color: #38bdf8;
    }

    #fileInput {
      display: none;
    }

    #fileList {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .file-card {
      border: 1px solid rgba(148,163,184,0.2);
      border-radius: 16px;
      padding: 1rem;
      background: rgba(15,23,42,0.8);
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 1rem;
      align-items: stretch;
    }

    .file-card canvas {
      width: 100%;
      border-radius: 12px;
      background: rgba(148,163,184,0.08);
      min-height: 120px;
      display: block;
    }

    .file-meta {
      color: #cbd5f5;
      font-size: 0.9rem;
      margin-bottom: 0.5rem;
    }

    .results details {
      border: 1px solid rgba(148,163,184,0.2);
      border-radius: 12px;
      margin-bottom: 0.5rem;
      background: rgba(2,6,23,0.85);
    }

    .results summary {
      cursor: pointer;
      padding: 0.75rem 1rem;
      font-weight: 600;
      color: #f8fafc;
      list-style: none;
    }

    .results pre {
      margin: 0;
      padding: 0 1rem 1rem;
      overflow-x: auto;
      font-size: 0.85rem;
      color: #e2e8f0;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.8rem;
      padding: 0.15rem 0.6rem;
      border-radius: 999px;
      background: rgba(148,163,184,0.2);
    }

    .badge.success {
      background: rgba(34,197,94,0.2);
      color: #4ade80;
    }

    .badge.error {
      background: rgba(248,113,113,0.2);
      color: #fca5a5;
    }

    .muted {
      color: #94a3b8;
      font-size: 0.85rem;
    }

    @media (max-width: 640px) {
      body {
        padding: 1.5rem;
      }
      .file-card {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>BFD9020 API Tester</h1>
    <p class="lede">Sequentially probe /xray-info, /xray-class, and flip/rot endpoints only when applicable.</p>
  </header>

  <section class="panel" aria-label="API configuration">
    <label>
      API base URL
      <input id="baseUrl" type="text" value="http://localhost:9020" spellcheck="false" />
    </label>
    <div style="margin-top: 0.75rem; display: flex; gap: 0.75rem; align-items: center;">
      <button id="pingBtn">Ping root</button>
      <span id="pingStatus" class="muted">Idle</span>
    </div>
  </section>

  <section class="panel" aria-label="Upload images">
    <div id="dropzone">
      <strong>Drag & drop</strong> DICOM exports / PNG / JPEG / TIFF here<br />
      <span class="muted">or click to browse your files</span>
    </div>
    <input id="fileInput" type="file" accept="image/png,image/jpeg,image/tiff" multiple />
  </section>

  <section class="panel" aria-label="Results">
    <h2 style="margin-top: 0;">Runs</h2>
    <div id="fileList" aria-live="polite"></div>
  </section>

  <template id="resultTemplate">
    <div class="file-card">
      <div>
        <canvas aria-label="preview"></canvas>
        <p class="file-meta"></p>
      </div>
      <div class="results"></div>
    </div>
  </template>

  <script src="/static/pako.min.js"></script>
  <script src="/static/UTIF.js"></script>
  <script>
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const fileList = document.getElementById('fileList');
    const baseUrlInput = document.getElementById('baseUrl');
    const pingBtn = document.getElementById('pingBtn');
    const pingStatus = document.getElementById('pingStatus');

    const sectionsMeta = [
      { key: 'info', label: 'X-ray Info', path: '/xray-info' },
      { key: 'class', label: 'X-ray Class', path: '/xray-class' },
      { key: 'lateral', label: 'Lateral Flip/Rot', path: '/lateral-fliprot' },
      { key: 'frontal', label: 'Frontal Flip/Rot', path: '/frontal-fliprot' },
    ];

    function getBaseUrl() {
      const value = baseUrlInput.value.trim();
      const fallback = 'http://localhost:9020';
      if (!value) return fallback;
      return value.endsWith('/') ? value.slice(0, -1) : value;
    }

    async function pingRoot() {
      const url = getBaseUrl();
      pingStatus.textContent = 'Pinging...';
      pingStatus.className = 'badge muted';
      try {
        const res = await fetch(url + '/');
        pingStatus.textContent = res.ok ? 'Root reachable' : `Error: ${res.status}`;
        pingStatus.className = res.ok ? 'badge success' : 'badge error';
      } catch (error) {
        pingStatus.textContent = 'Network error';
        pingStatus.className = 'badge error';
      }
    }

    pingBtn.addEventListener('click', pingRoot);

    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', (event) => {
      event.preventDefault();
      dropzone.classList.add('dragover');
    });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
    dropzone.addEventListener('drop', (event) => {
      event.preventDefault();
      dropzone.classList.remove('dragover');
      handleFiles(event.dataTransfer.files);
    });
    fileInput.addEventListener('change', () => handleFiles(fileInput.files));

    function handleFiles(fileListObj) {
      if (!fileListObj?.length) return;
      const files = Array.from(fileListObj);
      files.forEach(renderFileRun);
      fileInput.value = '';
    }

    function renderFileRun(file) {
      const template = document.getElementById('resultTemplate');
      const clone = template.content.cloneNode(true);
      const canvas = clone.querySelector('canvas');
      const meta = clone.querySelector('.file-meta');
      const results = clone.querySelector('.results');

      meta.textContent = `${file.name} â€¢ ${(file.size / (1024 * 1024)).toFixed(2)} MB`;
      fileList.prepend(clone);

      drawPreview(file, canvas);

      const sectionRefs = createSections(results);
      runPipeline(file, sectionRefs);
    }

    function ensureTiffDecoderLoaded() {
      return window.UTIF
        ? Promise.resolve(window.UTIF)
        : Promise.reject(new Error('TIFF decoder not initialized'));
    }

    async function drawPreview(file, canvas) {
      const ctx = canvas.getContext('2d');
      const maxDim = 240;

      const drawImageElement = (img) => {
        const scale = Math.min(maxDim / img.width, maxDim / img.height, 1) || 1;
        canvas.width = Math.max(1, Math.floor(img.width * scale));
        canvas.height = Math.max(1, Math.floor(img.height * scale));
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      };

      const drawFromImageData = (rgba, width, height) => {
        const imageData = new ImageData(new Uint8ClampedArray(rgba), width, height);
        const offscreen = document.createElement('canvas');
        offscreen.width = width;
        offscreen.height = height;
        offscreen.getContext('2d').putImageData(imageData, 0, 0);
        drawImageElement(offscreen);
      };

      try {
        if (file.type === 'image/tiff' || file.name.toLowerCase().endsWith('.tif') || file.name.toLowerCase().endsWith('.tiff')) {
          const UTIFRef = await ensureTiffDecoderLoaded();
          const buffer = await file.arrayBuffer();
          const ifds = UTIFRef.decode(buffer);
          if (!ifds.length) throw new Error('No TIFF frames');
          UTIFRef.decodeImage(buffer, ifds[0]);
          const rgba = UTIFRef.toRGBA8(ifds[0]);
          drawFromImageData(rgba, ifds[0].width, ifds[0].height);
        } else {
          const dataUrl = await readAsDataURL(file);
          await new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
              drawImageElement(img);
              resolve();
            };
            img.onerror = reject;
            img.src = dataUrl;
          });
        }
      } catch (error) {
        canvas.width = maxDim;
        canvas.height = 120;
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '12px "Inter", sans-serif';
        ctx.fillText('Anteprima non disponibile', 12, canvas.height / 2);
        console.warn('Preview failed', error);
      }
    }

    function readAsDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function createSections(resultsContainer) {
      const refs = {};
      sectionsMeta.forEach(({ key, label }) => {
        const details = document.createElement('details');
        details.open = true;
        const summary = document.createElement('summary');
        summary.innerHTML = `${label} <span class="badge muted">pending</span>`;
        const pre = document.createElement('pre');
        pre.textContent = '...';
        details.append(summary, pre);
        resultsContainer.append(details);
        refs[key] = { summary, pre, label };
      });
      return refs;
    }

    async function runPipeline(file, sections) {
      let predictedType = null;

      const info = await runAndRender(sections.info, () => runInference(file, '/xray-info'))
        .catch(() => null);
      if (info?.payload?.type_prediction) {
        predictedType = info.payload.type_prediction;
      }

      const cls = await runAndRender(sections.class, () => runInference(file, '/xray-class'))
        .catch(() => null);
      if (!predictedType && cls?.payload?.prediction) {
        predictedType = cls.payload.prediction;
      }

      if (!predictedType) return;
      const normalized = String(predictedType).toLowerCase();

      if (normalized.includes('lateral')) {
        await runAndRender(sections.lateral, () => runInference(file, '/lateral-fliprot'));
      } else if (normalized.includes('frontal')) {
        await runAndRender(sections.frontal, () => runInference(file, '/frontal-fliprot'));
      } else {
        sections.lateral.summary.innerHTML = `${sections.lateral.label} <span class="badge muted">skipped</span>`;
        sections.lateral.pre.textContent = 'Not a lateral prediction.';
        sections.frontal.summary.innerHTML = `${sections.frontal.label} <span class="badge muted">skipped</span>`;
        sections.frontal.pre.textContent = 'Not a frontal prediction.';
      }
    }

    async function runAndRender(section, task) {
      try {
        const { statusText, payload } = await task();
        section.summary.innerHTML = `${section.label} <span class="badge success">${statusText}</span>`;
        section.pre.textContent = JSON.stringify(payload, null, 2);
        return { payload };
      } catch (error) {
        section.summary.innerHTML = `${section.label} <span class="badge error">fail</span>`;
        section.pre.textContent = error.message || 'Unknown error';
        throw error;
      }
    }

    async function runInference(file, path) {
      const url = getBaseUrl() + path;
      const formData = new FormData();
      formData.append('image', file, file.name);

      const response = await fetch(url, { method: 'POST', body: formData });
      const text = await response.text();
      let payload = {};

      if (text) {
        try {
          payload = JSON.parse(text);
        } catch (error) {
          throw new Error(`Invalid JSON response (${response.status})\n${text}`);
        }
      }

      if (!response.ok) {
        throw new Error(JSON.stringify(payload, null, 2));
      }

      return { statusText: `${response.status}`, payload };
    }
  </script>
</body>
</html>
